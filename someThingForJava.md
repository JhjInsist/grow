

# java无继承关系类之间的转化

> 类型的转换必须是同类型之间，所以不同对象之间的转换本质是把两个对象想办法变成同一种类型
>
> 像子类转父类，子接口转父接口，由于子类继承于父类，所以父类包含子类，在转换过程中，系统将自动帮我们转换
>
> 父转子，系统不能识别，于是需要手动强制转换，并且只有在手动将两者的类型调为一致才可以成功，通常我们不会去调整两者的类型，所以表现出来的效果就是，有时候可以成功，有时候会失败
>





业务场景从redis取值时，有可能从redis里返回不同的类型 这些类型没有相应的继承关系但是属性基本相同因为业务场景关系不可以将他们使用同一实体类

解决办法：将从redis里的类转为 jsonObject 再将 jsonObject 转回需要接值的实体 理论上可以解决







# 命令行传参

希望运行程序时给主函数传参

psvm里的 args[]

![image-20220411211859132](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220411211859132.png)



# 可变参数

```java
public Demo{
    public static void main(String[] args){
    	Demo demo = new Demo();
        demo.test(1,2,3,4,5,6);
	}
    public void test(int... i);
    sout(i[1]);
    sout(i[2]);
    sout(i[3]);
    sout(i[4]);
    sout(i[5]);
    sout(i[6]);
}
```

可变参数的本质实现：数组



# 递归

自己调运自己 

- 递归头：什么时候停
- 递归体：什么时候调用自身

**必须有递归头，如果没有将陷入死循环**

```java
//求阶乘
int _(int num){
    if(num == 1){
        return 1;
    }
    else{
        return num*_(num-1);
    }
}
```



# 数组的

定义方式：

```JAVA
int[] nums; //正常定义
//int   nums[];//不推荐 方便与c或c++程序员
nums[] = new int[10];
```

# 内存分析



- **堆**

  存放new 的对象和数组

  可以被所有的线程共享但不会存放别的对象引用

- **栈**

  存放基本变量类型（会包含这个基本变量类型的数值）

  引用对象的变量（会存放这个引用在堆里面的地址）

- **方法区**

  可以被所有的线程共享

  包含了所有的class和所有的静态变量

  比如在定一个新的数组时

  ```java
  int[] arr;//在栈中添加了一个arr引用
  arr = new arr[10]//在堆中开辟内存 将引用指向堆
  for(){
      //给数组赋值
  }
  
  ```

  # 数组三种 初始化

  ```java
  int[] a = {1,2,3,4,5,6}//静态初始化
  int[] a = new int[10]; // 动态初始化（包含默认初始化）
  //默认初始化 创建空间后系统会给数组隐式初始化
  
  ```

  # 稀疏数组

  记录数组有几行几列和几种不同的有效值

  在第0行存入共几行几列

  从第一行开始记录每一个有效值的位置和数值

  稀疏数组会比有效值个数多一

  0 0 0 0 0

  1 0 0 0 0		原数组

  0 1 0 0 0 

  3 5 2

  1 0 1              稀疏数组

  2 1 1

# 面向对象本质：一类的方式组织代码，以对象的方式封装数据

# javaDoc

**javadoc是用来生成文档的**

**参数信息**

- @author  作者
- @version 版本号
- @since     指明需要最早使用的jdk版本
- @param 参数名
- @return 返回值
- @throws 异常抛出情况

javadoc 通过java生成文档

```cmd
javadoc - encoding UTF-8 -charest UTF-8 Doc.java
```



# 创建对象内存分析

```java
public class Pet{
    String name;
    int age;
    
    public void shout(){
        sout(叫了一声);
    }
}


psvm{
	new pet();
    pet.shout();
}
```



先将引用变量名存入栈中，同时在堆中分配一个空间将引用变量名指向内存空间；

# 封装

设计要求**高内聚低耦合**

- 高内聚 将类的内部数据自己完成

  比如类中属性的get set方法   属性私有 

  **具体有什么用？** 

  ​	可以对用户的操作进行一些校验和检查

封装的优点

1. 提高程序的安全性，保护数据
2. 隐藏代码的细节
3. 统一接口
4. 系统的可维护性增加了

# instanceof 和类型转换

instanceof可以用来检测两个类是否有继承关系

**高转低**

可以强制转换

可能丢失一些自己本来的方法

**低转高**

可能丢失一些自己本来的方法

# 关于 static

**找时间整理!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!**

# 关于接口

- 接口的本质是契约 是规范 如果使用则必须遵守这个规范
- 接口中的所有定义的方法都是 public abstract（默认）
- 接口中属性的定义都是常量 public static final
- 定义关键字interface
- 继承接口 implements
- implements 可以实现多个接口
- 接口都需要写实现类 通常命名为接口名+impl
- 实现了接口的类就必须重写接口中的所有方法
- 可以利用接口来侧面的实现多继承
- 接口不能实例化

**锻炼抽象的思维是非常难的，是成为一个架构师的必要条件**

# 内部类

在类的内部在定义一个类

1. 成员内部类

   ```java
   //类
   public class Outer{
       void out(){
           syso("这是外部类的方法");
       }
       class Inner{
           void out(){
               syso("这是内部类的方法");
           }
       }
   }
   //主函数
   class Main{
       main(){
           
       }
   }
   ```

   内部类可以获得外部类的私有属性和方法

   匿名内部类

   ```java
   //没有名字初始化类，不用将实例保存到变量中
   new Apple().eat();
   ```

   

# 关于异常机制

什么是异常

> 是指程序出现意外时的情况
>
>  有些是因为操作错误
>
> 有些是因为程序本身
>
> 错误不是异常

异常处理框架

> 异常（exception）和错误（error）都继承自Throwable

异常

- 运行时异常

  ​	这一类是异常分支中重要的子类RuntimeException

  jvm遇到异常时会抛出异常但是不会终止线程

  但是遇到错误时会直接终止线程

异常中的5个关键字

- try
- catch（） 参数是要捕获的异常，可以捕获多个异常，但是范围小的要写在上面
- finally(可以不要，一般用于进行善后工作)
- throw 可以主动抛出异常 一般在方法中使用，假设这个方法处理不了这个异常，可以用方法抛出异常；
- throws

自定义异常

- 自己定义的异常只需要继承excption类就可以类
- 只需要写一个构造器
- 然后用ToString（给）输出



# Byte 和 byte

Byte  不是**基本数据类型**而是 byte 的**封装类** 就如 Integer 和 int 使用时需要注意，不要混淆！！！！

